//
// This file was autogenerated.
//



CINTERFACE :: 1;
__REQUIRED_RPCNDR_H_VERSION__ :: 501;

__REQUIRED_RPCSAL_H_VERSION__ :: 100;

AUDCLNT_STREAMFLAGS_CROSSPROCESS :: 0x00010000;
AUDCLNT_STREAMFLAGS_LOOPBACK :: 0x00020000;
AUDCLNT_STREAMFLAGS_EVENTCALLBACK :: 0x00040000;
AUDCLNT_STREAMFLAGS_NOPERSIST :: 0x00080000;
AUDCLNT_STREAMFLAGS_RATEADJUST :: 0x00100000;
AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY :: 0x08000000;
AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM :: 0x80000000;
AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED :: 0x10000000;
AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE :: 0x20000000;
AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED :: 0x40000000;

AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ :: 0x00000001;

AMBISONICS_PARAM_VERSION_1 :: 1;

DEVICE_STATE_ACTIVE :: 0x00000001;
DEVICE_STATE_DISABLED :: 0x00000002;
DEVICE_STATE_NOTPRESENT :: 0x00000004;
DEVICE_STATE_UNPLUGGED :: 0x00000008;
DEVICE_STATEMASK_ALL :: 0x0000000f;

ENDPOINT_SYSFX_ENABLED :: 0x00000000;
ENDPOINT_SYSFX_DISABLED :: 0x00000001;

LPBYTE :: *u8;

LPCGUID :: *GUID;

PCONTEXT :: *_CONTEXT;

tWAVEFORMATEX :: struct {
    wFormatTag:      u16;
    nChannels:       u16;
    nSamplesPerSec:  u32;
    nAvgBytesPerSec: u32;
    nBlockAlign:     u16;
    wBitsPerSample:  u16;
    cbSize:          u16;
}

WAVEFORMATEX :: tWAVEFORMATEX;

OLECHAR :: u16;

BSTR :: *OLECHAR;

VARTYPE :: u16;

PROPERTYKEY :: _tagpropertykey;

STATSTG :: tagSTATSTG;

IStream :: struct {
    lpVtbl: *IStreamVtbl;
}

PROPVARIANT :: tagPROPVARIANT;

_AUDCLNT_SHAREMODE :: enum s32 {
    SHARED    :: 0;
    EXCLUSIVE :: 1;
}

AUDCLNT_SHAREMODE :: _AUDCLNT_SHAREMODE;

_AUDIO_STREAM_CATEGORY :: enum s32 {
    Other               :: 0;
    ForegroundOnlyMedia :: 1;

    Communications      :: 3;
    Alerts              :: 4;
    SoundEffects        :: 5;
    GameEffects         :: 6;
    GameMedia           :: 7;
    GameChat            :: 8;
    Speech              :: 9;
    Movie               :: 10;
    Media               :: 11;

    FarFieldSpeech      :: 12;
    UniformSpeech       :: 13;
    VoiceTyping         :: 14;
}

AUDIO_STREAM_CATEGORY :: _AUDIO_STREAM_CATEGORY;

_AudioSessionState :: enum s32 {
    Inactive :: 0;
    Active   :: 1;
    Expired  :: 2;
}

AudioSessionState :: _AudioSessionState;

REFERENCE_TIME :: s64;

_AUDCLNT_BUFFERFLAGS :: enum s32 {
    DATA_DISCONTINUITY :: 1;
    SILENT             :: 2;
    TIMESTAMP_ERROR    :: 4;
}

AUDCLNT_STREAMOPTIONS :: enum s32 {
    NONE         :: 0;
    RAW          :: 1;
    MATCH_FORMAT :: 2;
    AMBISONICS   :: 4;
}

AudioClientProperties :: struct {
    cbSize:     u32;
    bIsOffload: BOOL;
    eCategory:  AUDIO_STREAM_CATEGORY;
    Options:    AUDCLNT_STREAMOPTIONS;
}

IAudioClientVtbl :: struct {
    QueryInterface:    #type (This: *IAudioClient, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:            #type (This: *IAudioClient) -> u32 #c_call;

    Release:           #type (This: *IAudioClient) -> u32 #c_call;

    Initialize:        #type (This: *IAudioClient, ShareMode: AUDCLNT_SHAREMODE, StreamFlags: u32, hnsBufferDuration: REFERENCE_TIME, hnsPeriodicity: REFERENCE_TIME, pFormat: *WAVEFORMATEX, AudioSessionGuid: LPCGUID) -> HRESULT #c_call;

    GetBufferSize:     #type (This: *IAudioClient, pNumBufferFrames: *u32) -> HRESULT #c_call;

    GetStreamLatency:  #type (This: *IAudioClient, phnsLatency: *REFERENCE_TIME) -> HRESULT #c_call;

    GetCurrentPadding: #type (This: *IAudioClient, pNumPaddingFrames: *u32) -> HRESULT #c_call;

    IsFormatSupported: #type (This: *IAudioClient, ShareMode: AUDCLNT_SHAREMODE, pFormat: *WAVEFORMATEX, ppClosestMatch: **WAVEFORMATEX) -> HRESULT #c_call;

    GetMixFormat:      #type (This: *IAudioClient, ppDeviceFormat: **WAVEFORMATEX) -> HRESULT #c_call;

    GetDevicePeriod:   #type (This: *IAudioClient, phnsDefaultDevicePeriod: *REFERENCE_TIME, phnsMinimumDevicePeriod: *REFERENCE_TIME) -> HRESULT #c_call;

    Start:             #type (This: *IAudioClient) -> HRESULT #c_call;

    Stop:              #type (This: *IAudioClient) -> HRESULT #c_call;

    Reset:             #type (This: *IAudioClient) -> HRESULT #c_call;

    SetEventHandle:    #type (This: *IAudioClient, eventHandle: HANDLE) -> HRESULT #c_call;

    GetService:        #type (This: *IAudioClient, riid: *IID, ppv: **void) -> HRESULT #c_call;
}

IAudioClient :: struct {
    lpVtbl: *IAudioClientVtbl;
}

IAudioClient2Vtbl :: struct {
    QueryInterface:      #type (This: *IAudioClient2, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:              #type (This: *IAudioClient2) -> u32 #c_call;

    Release:             #type (This: *IAudioClient2) -> u32 #c_call;

    Initialize:          #type (This: *IAudioClient2, ShareMode: AUDCLNT_SHAREMODE, StreamFlags: u32, hnsBufferDuration: REFERENCE_TIME, hnsPeriodicity: REFERENCE_TIME, pFormat: *WAVEFORMATEX, AudioSessionGuid: LPCGUID) -> HRESULT #c_call;

    GetBufferSize:       #type (This: *IAudioClient2, pNumBufferFrames: *u32) -> HRESULT #c_call;

    GetStreamLatency:    #type (This: *IAudioClient2, phnsLatency: *REFERENCE_TIME) -> HRESULT #c_call;

    GetCurrentPadding:   #type (This: *IAudioClient2, pNumPaddingFrames: *u32) -> HRESULT #c_call;

    IsFormatSupported:   #type (This: *IAudioClient2, ShareMode: AUDCLNT_SHAREMODE, pFormat: *WAVEFORMATEX, ppClosestMatch: **WAVEFORMATEX) -> HRESULT #c_call;

    GetMixFormat:        #type (This: *IAudioClient2, ppDeviceFormat: **WAVEFORMATEX) -> HRESULT #c_call;

    GetDevicePeriod:     #type (This: *IAudioClient2, phnsDefaultDevicePeriod: *REFERENCE_TIME, phnsMinimumDevicePeriod: *REFERENCE_TIME) -> HRESULT #c_call;

    Start:               #type (This: *IAudioClient2) -> HRESULT #c_call;

    Stop:                #type (This: *IAudioClient2) -> HRESULT #c_call;

    Reset:               #type (This: *IAudioClient2) -> HRESULT #c_call;

    SetEventHandle:      #type (This: *IAudioClient2, eventHandle: HANDLE) -> HRESULT #c_call;

    GetService:          #type (This: *IAudioClient2, riid: *IID, ppv: **void) -> HRESULT #c_call;

    IsOffloadCapable:    #type (This: *IAudioClient2, Category: AUDIO_STREAM_CATEGORY, pbOffloadCapable: *BOOL) -> HRESULT #c_call;

    SetClientProperties: #type (This: *IAudioClient2, pProperties: *AudioClientProperties) -> HRESULT #c_call;

    GetBufferSizeLimits: #type (This: *IAudioClient2, pFormat: *WAVEFORMATEX, bEventDriven: BOOL, phnsMinBufferDuration: *REFERENCE_TIME, phnsMaxBufferDuration: *REFERENCE_TIME) -> HRESULT #c_call;
}

IAudioClient2 :: struct {
    lpVtbl: *IAudioClient2Vtbl;
}

AudioClient3ActivationParams :: struct {
    tracingContextId: GUID;
}

IAudioClient3Vtbl :: struct {
    QueryInterface:                   #type (This: *IAudioClient3, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:                           #type (This: *IAudioClient3) -> u32 #c_call;

    Release:                          #type (This: *IAudioClient3) -> u32 #c_call;

    Initialize:                       #type (This: *IAudioClient3, ShareMode: AUDCLNT_SHAREMODE, StreamFlags: u32, hnsBufferDuration: REFERENCE_TIME, hnsPeriodicity: REFERENCE_TIME, pFormat: *WAVEFORMATEX, AudioSessionGuid: LPCGUID) -> HRESULT #c_call;

    GetBufferSize:                    #type (This: *IAudioClient3, pNumBufferFrames: *u32) -> HRESULT #c_call;

    GetStreamLatency:                 #type (This: *IAudioClient3, phnsLatency: *REFERENCE_TIME) -> HRESULT #c_call;

    GetCurrentPadding:                #type (This: *IAudioClient3, pNumPaddingFrames: *u32) -> HRESULT #c_call;

    IsFormatSupported:                #type (This: *IAudioClient3, ShareMode: AUDCLNT_SHAREMODE, pFormat: *WAVEFORMATEX, ppClosestMatch: **WAVEFORMATEX) -> HRESULT #c_call;

    GetMixFormat:                     #type (This: *IAudioClient3, ppDeviceFormat: **WAVEFORMATEX) -> HRESULT #c_call;

    GetDevicePeriod:                  #type (This: *IAudioClient3, phnsDefaultDevicePeriod: *REFERENCE_TIME, phnsMinimumDevicePeriod: *REFERENCE_TIME) -> HRESULT #c_call;

    Start:                            #type (This: *IAudioClient3) -> HRESULT #c_call;

    Stop:                             #type (This: *IAudioClient3) -> HRESULT #c_call;

    Reset:                            #type (This: *IAudioClient3) -> HRESULT #c_call;

    SetEventHandle:                   #type (This: *IAudioClient3, eventHandle: HANDLE) -> HRESULT #c_call;

    GetService:                       #type (This: *IAudioClient3, riid: *IID, ppv: **void) -> HRESULT #c_call;

    IsOffloadCapable:                 #type (This: *IAudioClient3, Category: AUDIO_STREAM_CATEGORY, pbOffloadCapable: *BOOL) -> HRESULT #c_call;

    SetClientProperties:              #type (This: *IAudioClient3, pProperties: *AudioClientProperties) -> HRESULT #c_call;

    GetBufferSizeLimits:              #type (This: *IAudioClient3, pFormat: *WAVEFORMATEX, bEventDriven: BOOL, phnsMinBufferDuration: *REFERENCE_TIME, phnsMaxBufferDuration: *REFERENCE_TIME) -> HRESULT #c_call;

    GetSharedModeEnginePeriod:        #type (This: *IAudioClient3, pFormat: *WAVEFORMATEX, pDefaultPeriodInFrames: *u32, pFundamentalPeriodInFrames: *u32, pMinPeriodInFrames: *u32, pMaxPeriodInFrames: *u32) -> HRESULT #c_call;

    GetCurrentSharedModeEnginePeriod: #type (This: *IAudioClient3, ppFormat: **WAVEFORMATEX, pCurrentPeriodInFrames: *u32) -> HRESULT #c_call;

    InitializeSharedAudioStream:      #type (This: *IAudioClient3, StreamFlags: u32, PeriodInFrames: u32, pFormat: *WAVEFORMATEX, AudioSessionGuid: LPCGUID) -> HRESULT #c_call;
}

IAudioClient3 :: struct {
    lpVtbl: *IAudioClient3Vtbl;
}

IAudioRenderClientVtbl :: struct {
    QueryInterface: #type (This: *IAudioRenderClient, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:         #type (This: *IAudioRenderClient) -> u32 #c_call;

    Release:        #type (This: *IAudioRenderClient) -> u32 #c_call;

    GetBuffer:      #type (This: *IAudioRenderClient, NumFramesRequested: u32, ppData: **u8) -> HRESULT #c_call;

    ReleaseBuffer:  #type (This: *IAudioRenderClient, NumFramesWritten: u32, dwFlags: u32) -> HRESULT #c_call;
}

IAudioRenderClient :: struct {
    lpVtbl: *IAudioRenderClientVtbl;
}

IAudioCaptureClientVtbl :: struct {
    QueryInterface:    #type (This: *IAudioCaptureClient, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:            #type (This: *IAudioCaptureClient) -> u32 #c_call;

    Release:           #type (This: *IAudioCaptureClient) -> u32 #c_call;

    GetBuffer:         #type (This: *IAudioCaptureClient, ppData: **u8, pNumFramesToRead: *u32, pdwFlags: *u32, pu64DevicePosition: *u64, pu64QPCPosition: *u64) -> HRESULT #c_call;

    ReleaseBuffer:     #type (This: *IAudioCaptureClient, NumFramesRead: u32) -> HRESULT #c_call;

    GetNextPacketSize: #type (This: *IAudioCaptureClient, pNumFramesInNextPacket: *u32) -> HRESULT #c_call;
}

IAudioCaptureClient :: struct {
    lpVtbl: *IAudioCaptureClientVtbl;
}

IAudioClockVtbl :: struct {
    QueryInterface:     #type (This: *IAudioClock, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:             #type (This: *IAudioClock) -> u32 #c_call;

    Release:            #type (This: *IAudioClock) -> u32 #c_call;

    GetFrequency:       #type (This: *IAudioClock, pu64Frequency: *u64) -> HRESULT #c_call;

    GetPosition:        #type (This: *IAudioClock, pu64Position: *u64, pu64QPCPosition: *u64) -> HRESULT #c_call;

    GetCharacteristics: #type (This: *IAudioClock, pdwCharacteristics: *u32) -> HRESULT #c_call;
}

IAudioClock :: struct {
    lpVtbl: *IAudioClockVtbl;
}

IAudioClock2Vtbl :: struct {
    QueryInterface:    #type (This: *IAudioClock2, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:            #type (This: *IAudioClock2) -> u32 #c_call;

    Release:           #type (This: *IAudioClock2) -> u32 #c_call;

    GetDevicePosition: #type (This: *IAudioClock2, DevicePosition: *u64, QPCPosition: *u64) -> HRESULT #c_call;
}

IAudioClock2 :: struct {
    lpVtbl: *IAudioClock2Vtbl;
}

IAudioClockAdjustmentVtbl :: struct {
    QueryInterface: #type (This: *IAudioClockAdjustment, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:         #type (This: *IAudioClockAdjustment) -> u32 #c_call;

    Release:        #type (This: *IAudioClockAdjustment) -> u32 #c_call;

    SetSampleRate:  #type (This: *IAudioClockAdjustment, flSampleRate: float) -> HRESULT #c_call;
}

IAudioClockAdjustment :: struct {
    lpVtbl: *IAudioClockAdjustmentVtbl;
}

ISimpleAudioVolumeVtbl :: struct {
    QueryInterface:  #type (This: *ISimpleAudioVolume, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:          #type (This: *ISimpleAudioVolume) -> u32 #c_call;

    Release:         #type (This: *ISimpleAudioVolume) -> u32 #c_call;

    SetMasterVolume: #type (This: *ISimpleAudioVolume, fLevel: float, EventContext: LPCGUID) -> HRESULT #c_call;

    GetMasterVolume: #type (This: *ISimpleAudioVolume, pfLevel: *float) -> HRESULT #c_call;

    SetMute:         #type (This: *ISimpleAudioVolume, bMute: BOOL, EventContext: LPCGUID) -> HRESULT #c_call;

    GetMute:         #type (This: *ISimpleAudioVolume, pbMute: *BOOL) -> HRESULT #c_call;
}

ISimpleAudioVolume :: struct {
    lpVtbl: *ISimpleAudioVolumeVtbl;
}

AUDIO_DUCKING_OPTIONS :: enum s32 {
    DEFAULT                   :: 0;
    DO_NOT_DUCK_OTHER_STREAMS :: 1;
}

IAudioClientDuckingControlVtbl :: struct {
    QueryInterface:                    #type (This: *IAudioClientDuckingControl, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:                            #type (This: *IAudioClientDuckingControl) -> u32 #c_call;

    Release:                           #type (This: *IAudioClientDuckingControl) -> u32 #c_call;

    SetDuckingOptionsForCurrentStream: #type (This: *IAudioClientDuckingControl, options: AUDIO_DUCKING_OPTIONS) -> HRESULT #c_call;
}

IAudioClientDuckingControl :: struct {
    lpVtbl: *IAudioClientDuckingControlVtbl;
}

IAudioViewManagerServiceVtbl :: struct {
    QueryInterface:       #type (This: *IAudioViewManagerService, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:               #type (This: *IAudioViewManagerService) -> u32 #c_call;

    Release:              #type (This: *IAudioViewManagerService) -> u32 #c_call;

    SetAudioStreamWindow: #type (This: *IAudioViewManagerService, hwnd: HWND) -> HRESULT #c_call;
}

IAudioViewManagerService :: struct {
    lpVtbl: *IAudioViewManagerServiceVtbl;
}

AUDIO_EFFECT_STATE :: enum s32 {
    OFF :: 0;
    ON  :: 1;
}

AUDIO_EFFECT :: struct {
    id:          GUID;
    canSetState: BOOL;
    state:       AUDIO_EFFECT_STATE;
}

IAudioEffectsChangedNotificationClientVtbl :: struct {
    QueryInterface:        #type (This: *IAudioEffectsChangedNotificationClient, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:                #type (This: *IAudioEffectsChangedNotificationClient) -> u32 #c_call;

    Release:               #type (This: *IAudioEffectsChangedNotificationClient) -> u32 #c_call;

    OnAudioEffectsChanged: #type (This: *IAudioEffectsChangedNotificationClient) -> HRESULT #c_call;
}

IAudioEffectsChangedNotificationClient :: struct {
    lpVtbl: *IAudioEffectsChangedNotificationClientVtbl;
}

IAudioEffectsManagerVtbl :: struct {
    QueryInterface:                                    #type (This: *IAudioEffectsManager, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:                                            #type (This: *IAudioEffectsManager) -> u32 #c_call;

    Release:                                           #type (This: *IAudioEffectsManager) -> u32 #c_call;

    RegisterAudioEffectsChangedNotificationCallback:   #type (This: *IAudioEffectsManager, client: *IAudioEffectsChangedNotificationClient) -> HRESULT #c_call;

    UnregisterAudioEffectsChangedNotificationCallback: #type (This: *IAudioEffectsManager, client: *IAudioEffectsChangedNotificationClient) -> HRESULT #c_call;

    GetAudioEffects:                                   #type (This: *IAudioEffectsManager, effects: **AUDIO_EFFECT, numEffects: *u32) -> HRESULT #c_call;

    SetAudioEffectState:                               #type (This: *IAudioEffectsManager, effectId: GUID, state: AUDIO_EFFECT_STATE) -> HRESULT #c_call;
}

IAudioEffectsManager :: struct {
    lpVtbl: *IAudioEffectsManagerVtbl;
}

IAudioStreamVolumeVtbl :: struct {
    QueryInterface:   #type (This: *IAudioStreamVolume, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:           #type (This: *IAudioStreamVolume) -> u32 #c_call;

    Release:          #type (This: *IAudioStreamVolume) -> u32 #c_call;

    GetChannelCount:  #type (This: *IAudioStreamVolume, pdwCount: *u32) -> HRESULT #c_call;

    SetChannelVolume: #type (This: *IAudioStreamVolume, dwIndex: u32, fLevel: float) -> HRESULT #c_call;

    GetChannelVolume: #type (This: *IAudioStreamVolume, dwIndex: u32, pfLevel: *float) -> HRESULT #c_call;

    SetAllVolumes:    #type (This: *IAudioStreamVolume, dwCount: u32, pfVolumes: *float) -> HRESULT #c_call;

    GetAllVolumes:    #type (This: *IAudioStreamVolume, dwCount: u32, pfVolumes: *float) -> HRESULT #c_call;
}

IAudioStreamVolume :: struct {
    lpVtbl: *IAudioStreamVolumeVtbl;
}

AMBISONICS_TYPE :: enum s32 {
    FULL3D :: 0;
}

AMBISONICS_CHANNEL_ORDERING :: enum s32 {
    ACN :: 0;
}

AMBISONICS_NORMALIZATION :: enum s32 {
    SN3D :: 0;
    N3D  :: 1;
}

AMBISONICS_PARAMS :: struct {
    u32Size:            u32;
    u32Version:         u32;
    u32Type:            AMBISONICS_TYPE;
    u32ChannelOrdering: AMBISONICS_CHANNEL_ORDERING;
    u32Normalization:   AMBISONICS_NORMALIZATION;
    u32Order:           u32;
    u32NumChannels:     u32;

    pu32ChannelMap:     *u32;
}

IAudioAmbisonicsControlVtbl :: struct {
    QueryInterface:  #type (This: *IAudioAmbisonicsControl, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:          #type (This: *IAudioAmbisonicsControl) -> u32 #c_call;

    Release:         #type (This: *IAudioAmbisonicsControl) -> u32 #c_call;

    SetData:         #type (This: *IAudioAmbisonicsControl, pAmbisonicsParams: *AMBISONICS_PARAMS, cbAmbisonicsParams: u32) -> HRESULT #c_call;

    SetHeadTracking: #type (This: *IAudioAmbisonicsControl, bEnableHeadTracking: BOOL) -> HRESULT #c_call;

    GetHeadTracking: #type (This: *IAudioAmbisonicsControl, pbEnableHeadTracking: *BOOL) -> HRESULT #c_call;

    SetRotation:     #type (This: *IAudioAmbisonicsControl, X: float, Y: float, Z: float, W: float) -> HRESULT #c_call;
}

IAudioAmbisonicsControl :: struct {
    lpVtbl: *IAudioAmbisonicsControlVtbl;
}

IChannelAudioVolumeVtbl :: struct {
    QueryInterface:   #type (This: *IChannelAudioVolume, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:           #type (This: *IChannelAudioVolume) -> u32 #c_call;

    Release:          #type (This: *IChannelAudioVolume) -> u32 #c_call;

    GetChannelCount:  #type (This: *IChannelAudioVolume, pdwCount: *u32) -> HRESULT #c_call;

    SetChannelVolume: #type (This: *IChannelAudioVolume, dwIndex: u32, fLevel: float, EventContext: LPCGUID) -> HRESULT #c_call;

    GetChannelVolume: #type (This: *IChannelAudioVolume, dwIndex: u32, pfLevel: *float) -> HRESULT #c_call;

    SetAllVolumes:    #type (This: *IChannelAudioVolume, dwCount: u32, pfVolumes: *float, EventContext: LPCGUID) -> HRESULT #c_call;

    GetAllVolumes:    #type (This: *IChannelAudioVolume, dwCount: u32, pfVolumes: *float) -> HRESULT #c_call;
}

IChannelAudioVolume :: struct {
    lpVtbl: *IChannelAudioVolumeVtbl;
}

IAcousticEchoCancellationControlVtbl :: struct {
    QueryInterface:                    #type (This: *IAcousticEchoCancellationControl, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:                            #type (This: *IAcousticEchoCancellationControl) -> u32 #c_call;

    Release:                           #type (This: *IAcousticEchoCancellationControl) -> u32 #c_call;

    SetEchoCancellationRenderEndpoint: #type (This: *IAcousticEchoCancellationControl, endpointId: *u16) -> HRESULT #c_call;
}

IAcousticEchoCancellationControl :: struct {
    lpVtbl: *IAcousticEchoCancellationControlVtbl;
}

MMDeviceEnumerator :: struct {}

SHCOLSTATEF :: u32;

CONDITION_OPERATION :: tagCONDITION_OPERATION;

IPropertyStoreVtbl :: struct {
    QueryInterface: #type (This: *IPropertyStore, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:         #type (This: *IPropertyStore) -> u32 #c_call;

    Release:        #type (This: *IPropertyStore) -> u32 #c_call;

    GetCount:       #type (This: *IPropertyStore, cProps: *u32) -> HRESULT #c_call;

    GetAt:          #type (This: *IPropertyStore, iProp: u32, pkey: *PROPERTYKEY) -> HRESULT #c_call;

    GetValue:       #type (This: *IPropertyStore, key: *PROPERTYKEY, pv: *PROPVARIANT) -> HRESULT #c_call;

    SetValue:       #type (This: *IPropertyStore, key: *PROPERTYKEY, propvar: *PROPVARIANT) -> HRESULT #c_call;

    Commit:         #type (This: *IPropertyStore) -> HRESULT #c_call;
}

IPropertyStore :: struct {
    lpVtbl: *IPropertyStoreVtbl;
}

tagDIRECTX_AUDIO_ACTIVATION_PARAMS :: struct {
    cbDirectXAudioActivationParams: u32;
    guidAudioSession:               GUID;
    dwAudioStreamFlags:             u32;
}

DIRECTX_AUDIO_ACTIVATION_PARAMS :: tagDIRECTX_AUDIO_ACTIVATION_PARAMS;

PDIRECTX_AUDIO_ACTIVATION_PARAMS :: *tagDIRECTX_AUDIO_ACTIVATION_PARAMS;

__MIDL___MIDL_itf_mmdeviceapi_0000_0000_0001 :: enum s32 {
    eRender              :: 0;
    eCapture             :: 1;
    eAll                 :: 2;
    EDataFlow_enum_count :: 3;
}

EDataFlow :: __MIDL___MIDL_itf_mmdeviceapi_0000_0000_0001;

__MIDL___MIDL_itf_mmdeviceapi_0000_0000_0002 :: enum s32 {
    eConsole         :: 0;
    eMultimedia      :: 1;
    eCommunications  :: 2;
    ERole_enum_count :: 3;
}

ERole :: __MIDL___MIDL_itf_mmdeviceapi_0000_0000_0002;

__MIDL___MIDL_itf_mmdeviceapi_0000_0000_0003 :: enum s32 {
    RemoteNetworkDevice           :: 0;
    Speakers                      :: 1;
    LineLevel                     :: 2;
    Headphones                    :: 3;
    Microphone                    :: 4;
    Headset                       :: 5;
    Handset                       :: 6;
    UnknownDigitalPassthrough     :: 7;
    SPDIF                         :: 8;
    DigitalAudioDisplayDevice     :: 9;
    UnknownFormFactor             :: 10;
    EndpointFormFactor_enum_count :: 11;
}

EndpointFormFactor :: __MIDL___MIDL_itf_mmdeviceapi_0000_0000_0003;

IMMNotificationClientVtbl :: struct {
    QueryInterface:         #type (This: *IMMNotificationClient, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:                 #type (This: *IMMNotificationClient) -> u32 #c_call;

    Release:                #type (This: *IMMNotificationClient) -> u32 #c_call;

    OnDeviceStateChanged:   #type (This: *IMMNotificationClient, pwstrDeviceId: *u16, dwNewState: u32) -> HRESULT #c_call;

    OnDeviceAdded:          #type (This: *IMMNotificationClient, pwstrDeviceId: *u16) -> HRESULT #c_call;

    OnDeviceRemoved:        #type (This: *IMMNotificationClient, pwstrDeviceId: *u16) -> HRESULT #c_call;

    OnDefaultDeviceChanged: #type (This: *IMMNotificationClient, flow: EDataFlow, role: ERole, pwstrDefaultDeviceId: *u16) -> HRESULT #c_call;

    OnPropertyValueChanged: #type (This: *IMMNotificationClient, pwstrDeviceId: *u16, key: PROPERTYKEY) -> HRESULT #c_call;
}

IMMNotificationClient :: struct {
    lpVtbl: *IMMNotificationClientVtbl;
}

IMMDeviceVtbl :: struct {
    QueryInterface:    #type (This: *IMMDevice, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:            #type (This: *IMMDevice) -> u32 #c_call;

    Release:           #type (This: *IMMDevice) -> u32 #c_call;

    Activate:          #type (This: *IMMDevice, iid: *IID, dwClsCtx: u32, pActivationParams: *PROPVARIANT, ppInterface: **void) -> HRESULT #c_call;

    OpenPropertyStore: #type (This: *IMMDevice, stgmAccess: u32, ppProperties: **IPropertyStore) -> HRESULT #c_call;

    GetId:             #type (This: *IMMDevice, ppstrId: **u16) -> HRESULT #c_call;

    GetState:          #type (This: *IMMDevice, pdwState: *u32) -> HRESULT #c_call;
}

IMMDevice :: struct {
    lpVtbl: *IMMDeviceVtbl;
}

IMMDeviceCollectionVtbl :: struct {
    QueryInterface: #type (This: *IMMDeviceCollection, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:         #type (This: *IMMDeviceCollection) -> u32 #c_call;

    Release:        #type (This: *IMMDeviceCollection) -> u32 #c_call;

    GetCount:       #type (This: *IMMDeviceCollection, pcDevices: *u32) -> HRESULT #c_call;

    Item:           #type (This: *IMMDeviceCollection, nDevice: u32, ppDevice: **IMMDevice) -> HRESULT #c_call;
}

IMMDeviceCollection :: struct {
    lpVtbl: *IMMDeviceCollectionVtbl;
}

IMMEndpointVtbl :: struct {
    QueryInterface: #type (This: *IMMEndpoint, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:         #type (This: *IMMEndpoint) -> u32 #c_call;

    Release:        #type (This: *IMMEndpoint) -> u32 #c_call;

    GetDataFlow:    #type (This: *IMMEndpoint, pDataFlow: *EDataFlow) -> HRESULT #c_call;
}

IMMEndpoint :: struct {
    lpVtbl: *IMMEndpointVtbl;
}

IMMDeviceEnumeratorVtbl :: struct {
    QueryInterface:                         #type (This: *IMMDeviceEnumerator, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:                                 #type (This: *IMMDeviceEnumerator) -> u32 #c_call;

    Release:                                #type (This: *IMMDeviceEnumerator) -> u32 #c_call;

    EnumAudioEndpoints:                     #type (This: *IMMDeviceEnumerator, dataFlow: EDataFlow, dwStateMask: u32, ppDevices: **IMMDeviceCollection) -> HRESULT #c_call;

    GetDefaultAudioEndpoint:                #type (This: *IMMDeviceEnumerator, dataFlow: EDataFlow, role: ERole, ppEndpoint: **IMMDevice) -> HRESULT #c_call;

    GetDevice:                              #type (This: *IMMDeviceEnumerator, pwstrId: *u16, ppDevice: **IMMDevice) -> HRESULT #c_call;

    RegisterEndpointNotificationCallback:   #type (This: *IMMDeviceEnumerator, pClient: *IMMNotificationClient) -> HRESULT #c_call;

    UnregisterEndpointNotificationCallback: #type (This: *IMMDeviceEnumerator, pClient: *IMMNotificationClient) -> HRESULT #c_call;
}

IMMDeviceEnumerator :: struct {
    lpVtbl: *IMMDeviceEnumeratorVtbl;
}

IMMDeviceActivatorVtbl :: struct {
    QueryInterface: #type (This: *IMMDeviceActivator, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:         #type (This: *IMMDeviceActivator) -> u32 #c_call;

    Release:        #type (This: *IMMDeviceActivator) -> u32 #c_call;

    Activate:       #type (This: *IMMDeviceActivator, iid: *IID, pDevice: *IMMDevice, pActivationParams: *PROPVARIANT, ppInterface: **void) -> HRESULT #c_call;
}

IMMDeviceActivator :: struct {
    lpVtbl: *IMMDeviceActivatorVtbl;
}

IActivateAudioInterfaceCompletionHandlerVtbl :: struct {
    QueryInterface:    #type (This: *IActivateAudioInterfaceCompletionHandler, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:            #type (This: *IActivateAudioInterfaceCompletionHandler) -> u32 #c_call;

    Release:           #type (This: *IActivateAudioInterfaceCompletionHandler) -> u32 #c_call;

    ActivateCompleted: #type (This: *IActivateAudioInterfaceCompletionHandler, activateOperation: *IActivateAudioInterfaceAsyncOperation) -> HRESULT #c_call;
}

IActivateAudioInterfaceCompletionHandler :: struct {
    lpVtbl: *IActivateAudioInterfaceCompletionHandlerVtbl;
}

IActivateAudioInterfaceAsyncOperationVtbl :: struct {
    QueryInterface:    #type (This: *IActivateAudioInterfaceAsyncOperation, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:            #type (This: *IActivateAudioInterfaceAsyncOperation) -> u32 #c_call;

    Release:           #type (This: *IActivateAudioInterfaceAsyncOperation) -> u32 #c_call;

    GetActivateResult: #type (This: *IActivateAudioInterfaceAsyncOperation, activateResult: *HRESULT, activatedInterface: **IUnknown) -> HRESULT #c_call;
}

IActivateAudioInterfaceAsyncOperation :: struct {
    lpVtbl: *IActivateAudioInterfaceAsyncOperationVtbl;
}

__MIDL___MIDL_itf_mmdeviceapi_0000_0008_0001 :: struct {
    AddPageParam:  LPARAM;
    pEndpoint:     *IMMDevice;
    pPnpInterface: *IMMDevice;
    pPnpDevnode:   *IMMDevice;
}

AudioExtensionParams :: __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0001;

__MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002 :: enum s32 {
    DEFAULT    :: 0;
    USER       :: 1;
    VOLATILE   :: 2;
    ENUM_COUNT :: 3;
}

AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE :: __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002;

IAudioSystemEffectsPropertyChangeNotificationClientVtbl :: struct {
    QueryInterface:    #type (This: *IAudioSystemEffectsPropertyChangeNotificationClient, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:            #type (This: *IAudioSystemEffectsPropertyChangeNotificationClient) -> u32 #c_call;

    Release:           #type (This: *IAudioSystemEffectsPropertyChangeNotificationClient) -> u32 #c_call;

    OnPropertyChanged: #type (This: *IAudioSystemEffectsPropertyChangeNotificationClient, type: AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE, key: PROPERTYKEY) -> HRESULT #c_call;
}

IAudioSystemEffectsPropertyChangeNotificationClient :: struct {
    lpVtbl: *IAudioSystemEffectsPropertyChangeNotificationClientVtbl;
}

IAudioSystemEffectsPropertyStoreVtbl :: struct {
    QueryInterface:                       #type (This: *IAudioSystemEffectsPropertyStore, riid: *IID, ppvObject: **void) -> HRESULT #c_call;

    AddRef:                               #type (This: *IAudioSystemEffectsPropertyStore) -> u32 #c_call;

    Release:                              #type (This: *IAudioSystemEffectsPropertyStore) -> u32 #c_call;

    OpenDefaultPropertyStore:             #type (This: *IAudioSystemEffectsPropertyStore, stgmAccess: u32, propStore: **IPropertyStore) -> HRESULT #c_call;

    OpenUserPropertyStore:                #type (This: *IAudioSystemEffectsPropertyStore, stgmAccess: u32, propStore: **IPropertyStore) -> HRESULT #c_call;

    OpenVolatilePropertyStore:            #type (This: *IAudioSystemEffectsPropertyStore, stgmAccess: u32, propStore: **IPropertyStore) -> HRESULT #c_call;

    ResetUserPropertyStore:               #type (This: *IAudioSystemEffectsPropertyStore) -> HRESULT #c_call;

    ResetVolatilePropertyStore:           #type (This: *IAudioSystemEffectsPropertyStore) -> HRESULT #c_call;

    RegisterPropertyChangeNotification:   #type (This: *IAudioSystemEffectsPropertyStore, callback: *IAudioSystemEffectsPropertyChangeNotificationClient) -> HRESULT #c_call;

    UnregisterPropertyChangeNotification: #type (This: *IAudioSystemEffectsPropertyStore, callback: *IAudioSystemEffectsPropertyChangeNotificationClient) -> HRESULT #c_call;
}

IAudioSystemEffectsPropertyStore :: struct {
    lpVtbl: *IAudioSystemEffectsPropertyStoreVtbl;
}

#scope_file

ole32 :: #library,system "ole32";
